// -*- C++ -*- generated by wxGlade 0.6.5 on Mon Jun 04 08:30:53 2012 from "C:\dpo\tools\scripts\cta\cta.wxg"

#include "CTAFrame.h"

#define SUPUPPORT_UTF8
#define SUPPORT_UCP
#include "pcrecpp.h"

#include "Utils.h"
#include "NewVarDlg.h"
#include "ImportDlg.h"
#include <algorithm>

// begin wxGlade: ::extracode

// end wxGlade

#define DELIM L';'
wxColour system_colour = wxColour(249, 255, 185);
wxColour default_background_button = wxColour(240, 240, 240);
wxColour yellow = wxColour(255, 255, 0);
wxColour bad_order_background = wxColour(255, 0, 0);
wxColour bad_order_foreground = wxColour(255, 255, 255);
wxColour bad_path_background = wxColour(255, 255, 0);
wxColour bad_path_foreground = wxColour(0, 0, 0);

CTAFrame::CTAFrame(wxWindow* parent, int id, const wxString& title, const wxPoint& pos, const wxSize& size, long style):
    wxFrame(parent, id, title, pos, size, wxDEFAULT_FRAME_STYLE)
    , env_vars_user_(EnvVarVect::user)
    , env_vars_system_(EnvVarVect::system)
    , initial_user_env_vars_(EnvVarVect::user)
    , initial_system_env_vars_(EnvVarVect::system)
    , active_env_vars_(&env_vars_user_)
    , admin_(false)
    , cta_is_changing_setting_(false)
    , setting_changed_from_outside_(false)
{
    // begin wxGlade: CTAFrame::CTAFrame
    notebook_1_ = new wxNotebook(this, wxID_HIGHEST + wxID_notbook1, wxDefaultPosition, wxDefaultSize, 0);
    notebook_1_pane_system_ = new wxPanel(notebook_1_, wxID_ANY);
    notebook_1_pane_user_ = new wxPanel(notebook_1_, wxID_ANY);
    sizer_8_staticbox = new wxStaticBox(notebook_1_pane_system_, -1, wxEmptyString);
    sizer_7_staticbox = new wxStaticBox(notebook_1_pane_user_, -1, wxEmptyString);
    tree_ctrl_user_ = new wxTreeCtrl(notebook_1_pane_user_, wxID_HIGHEST + wxID_tree_user, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_NO_LINES|wxTR_LINES_AT_ROOT|wxTR_EDIT_LABELS|wxTR_HIDE_ROOT|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER|wxWANTS_CHARS);
    button_user_new_var_ = new wxButton(notebook_1_pane_user_, wxID_HIGHEST + wxID_button_user_new_var, wxT("New variable..."));
    button_user_new_value_ = new wxButton(notebook_1_pane_user_, wxID_HIGHEST + wxID_button_user_new_value, wxT("New value..."));
    button_user_delete_ = new wxButton(notebook_1_pane_user_, wxID_HIGHEST + wxID_button_user_delete, wxT("Delete"));
    tree_ctrl_system_ = new wxTreeCtrl(notebook_1_pane_system_, wxID_HIGHEST + wxID_tree_system, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_NO_LINES|wxTR_LINES_AT_ROOT|wxTR_EDIT_LABELS|wxTR_HIDE_ROOT|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    button_system_new_ = new wxButton(notebook_1_pane_system_, wxID_HIGHEST + wxID_button_system_new_var, wxT("New variable..."));
    button_system_new_value_ = new wxButton(notebook_1_pane_system_, wxID_HIGHEST + wxID_button_system_new_value, wxT("New value..."));
    button_system_delete_ = new wxButton(notebook_1_pane_system_, wxID_HIGHEST + wxID_button_system_delete, wxT("Delete"));
    bitmap_admin = new wxStaticBitmap(notebook_1_pane_system_, wxID_ANY, wxNullBitmap);
    const wxString *list_box_msg_choices = NULL;
    list_box_msg = new wxListBox(this, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0, list_box_msg_choices, 0);
    bitmap_gpl = new wxStaticBitmap(this, wxID_ANY, wxNullBitmap);
    button_about_ = new wxButton(this, wxID_HIGHEST + wxID_button_about, wxT("About..."));
    checkbox_sorted_ = new wxCheckBox(this, wxID_HIGHEST + wxID_checkbox_sort, wxT("sorted"));
    button_up_ = new wxButton(this, wxID_HIGHEST + wxID_button_up, wxT("Up"));
    button_down_ = new wxButton(this, wxID_HIGHEST + wxID_button_down, wxT("Down"));
    button_fix_ = new wxButton(this, wxID_HIGHEST + wxID_button_fix, wxT("Fix"));
    button_reload_ = new wxButton(this, wxID_HIGHEST + wxID_button_reload, wxT("Reload..."));
    button_export_ = new wxButton(this, wxID_HIGHEST + wxID_button_export, wxT("Export"));
    button_import_ = new wxButton(this, wxID_HIGHEST + wxID_button_import, wxT("Import..."));
    button_save_ = new wxButton(this, wxID_HIGHEST + wxID_button_save, wxT("Save"));
    button_quit_ = new wxButton(this, wxID_HIGHEST + wxID_button_quit, wxT("Quit"));

    set_properties();
    do_layout();
    // end wxGlade

    // We need to know if CTA has been launched as Administrator.
    get_admin_status();

    // Load environment variables (user and system ones)
    load_env_vars();

    // Set the user tree as active (the one that is seen in notebook)
    active_tree_ = tree_ctrl_user_;

    // Keep initial states for env. vars.
    // Used to know if data are dirty and to revert in case of error.
    initial_user_env_vars_ = env_vars_user_;
    initial_system_env_vars_ = env_vars_system_;

    // It is easier to find variables if they are sorted
    checkbox_sorted_->SetValue(1);

    // Enable up/down buttons only when checkbox_sorted_ is unchecked.
    button_up_->Enable(0);
    button_down_->Enable(0);

    // Because I decided to offer the move feature, I comment these 3 lines.
    // checkbox_sorted_->Hide();
    // button_up_->Hide();
    // button_down_->Hide();

    // Can exit quickly
    button_quit_->SetDefault();

    // Resfresh the current tree (here, it is user env. vars. tree)
    reset_tree();

    // cta icon
    SetIcon(wxIcon("mainicon"));

    bitmap_admin->SetBitmap(wxBITMAP(IDB_BITMAP_LOCK));
    //~ bitmap_gpl->SetBitmap(wxBITMAP(IDB_BITMAP_GPL));
}


BEGIN_EVENT_TABLE(CTAFrame, wxFrame)
    // begin wxGlade: CTAFrame::event_table
    EVT_TREE_ITEM_EXPANDING(wxID_HIGHEST + wxID_tree_user, CTAFrame::on_expanding)
    EVT_TREE_KEY_DOWN(wxID_HIGHEST + wxID_tree_user, CTAFrame::on_tree_key_down)
    EVT_TREE_END_LABEL_EDIT(wxID_HIGHEST + wxID_tree_user, CTAFrame::on_end_edit)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_user_new_var, CTAFrame::on_new_var)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_user_new_value, CTAFrame::on_new_value)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_user_delete, CTAFrame::on_delete)
    EVT_TREE_ITEM_EXPANDING(wxID_HIGHEST + wxID_tree_system, CTAFrame::on_expanding)
    EVT_TREE_KEY_DOWN(wxID_HIGHEST + wxID_tree_system, CTAFrame::on_tree_key_down)
    EVT_TREE_END_LABEL_EDIT(wxID_HIGHEST + wxID_tree_system, CTAFrame::on_end_edit)
    EVT_TREE_BEGIN_LABEL_EDIT(wxID_HIGHEST + wxID_tree_system, CTAFrame::on_begin_edit)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_system_new_var, CTAFrame::on_new_var)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_system_new_value, CTAFrame::on_new_value)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_system_delete, CTAFrame::on_delete)
    EVT_NOTEBOOK_PAGE_CHANGED(wxID_HIGHEST + wxID_notbook1, CTAFrame::on_page_change)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_about, CTAFrame::on_button_about)
    EVT_CHECKBOX(wxID_HIGHEST + wxID_checkbox_sort, CTAFrame::on_sort)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_up, CTAFrame::on_button_up)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_down, CTAFrame::on_button_down)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_fix, CTAFrame::on_button_fix)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_reload, CTAFrame::on_button_reload)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_export, CTAFrame::on_button_export)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_import, CTAFrame::on_button_import)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_save, CTAFrame::on_button_save)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_quit, CTAFrame::on_quit)
    // end wxGlade

    // wxGlade forgot to generate them...
    EVT_TREE_ITEM_RIGHT_CLICK(wxID_HIGHEST + wxID_tree_user, CTAFrame::on_item_right_click)
    EVT_TREE_ITEM_RIGHT_CLICK(wxID_HIGHEST  + wxID_tree_system, CTAFrame::on_item_right_click)
    EVT_MENU(POPUP_NEW_VALUE, CTAFrame::on_new_value)
    EVT_MENU(POPUP_DELETE, CTAFrame::on_delete)
    EVT_CLOSE(CTAFrame::on_close)

END_EVENT_TABLE();


void CTAFrame::on_expanding(wxTreeEvent &event)
{
    // to avoid element selection of first tree item on expanding
    // when there was no element selected previously

    wxTreeItemId selected_item = active_tree_->GetSelection();
    if (!selected_item.IsOk())
    {
        active_tree_->SelectItem(event.GetItem());
    }
}


void CTAFrame::on_tree_key_down(wxTreeEvent &event)
{
    // In some software, we can often use F2 to edit entry
    // and del to delete entry. That is what we allow here.

    if (!is_admin() && active_tree_ == tree_ctrl_system_)
    {
        return;
    }

    int key_code = event.GetKeyCode();

    if (key_code == WXK_F2)
    {
        // Edit
        wxTreeItemId selected_item = active_tree_->GetSelection();

        if (!selected_item.IsOk())
        {
            return;
        }

        active_tree_->EditLabel(selected_item);
    }

    if (key_code == WXK_DELETE)
    {
        // Delete
        on_delete(event);
    }
}


void CTAFrame::on_end_edit(wxTreeEvent &event)
{
    if (event.IsEditCancelled())
    {
        return;
    }

    wxTreeItemId item = event.GetItem();

    if (item.IsOk())
    {
        std::wstring sel_item_text = active_tree_->GetItemText(item).ToStdWstring();
        std::wstring new_item_text = event.GetLabel().ToStdWstring();

        wxTreeItemId item_parent = active_tree_->GetItemParent(item);
        wxTreeItemId root = active_tree_->GetRootItem();

        // Allow empty value only, not empty variable.
        if (new_item_text.length() == 0
            && (item_parent == root))
        {
            event.Veto();
            return;
        }

        // Used to select item after resetting the tree.
        std::wstring current_selection_text;

        if (item_parent == root)  // variable
        {
            if (std::find(active_env_vars_->begin(),
                            active_env_vars_->end(),
                            new_item_text) != active_env_vars_->end())
            {
                wxMessageBox(
                    new_item_text  + L" already exists.",
                    "Edit variable",
                    wxOK | wxICON_WARNING);
                event.Veto();
            }
            else
            {
                // If variable name changed, we must regenerate the vector.
                std::vector<EnvVar> new_keys;

                EnvVarVect::iterator it;
                for (it = active_env_vars_->begin(); it != active_env_vars_->end(); it++)
                {
                    std::wstring key = it->key_;
                    std::wstring value = it->value_;

                    if (key == sel_item_text)
                    {
                        EnvVar var(new_item_text, value);
                        new_keys.push_back(var);
                    }
                    else
                    {
                        EnvVar var(key, value);
                        new_keys.push_back(var);
                    }
                }

                active_env_vars_->clear();
                *active_env_vars_ = new_keys;

                current_selection_text = new_item_text;
            }
        }
        else  // value
        {
            std::wstring parent_text = active_tree_->GetItemText(item_parent).ToStdWstring();
            std::wstring all_values;
            active_env_vars_->get_value(parent_text, all_values);

            // Parse values to work on each value entity.
            std::vector<std::wstring> tokens = parse(all_values, DELIM);

            std::vector<std::wstring> keep;
            std::vector<std::wstring>::iterator tok;
            for (tok = tokens.begin(); tok != tokens.end(); tok++)
            {
                if (*tok == sel_item_text)
                {
                    // Replace with new value
                    keep.push_back(new_item_text);
                }
                else
                {
                    // Keep the current value
                    keep.push_back(*tok);
                }
            }

            // Rebuild string
            std::wstring new_values(L"");
            for (tok = keep.begin(); tok != keep.end(); tok++)
            {
                if (new_values.length() != 0)
                {
                    new_values += L";";
                }

                new_values += *tok;
            }

            // Update the value
            active_env_vars_->set_value(parent_text, new_values);

            current_selection_text = parent_text;

            std::vector<std::wstring> vect = parse(new_item_text, DELIM);
            if (vect.size() == 1)
            {
                current_selection_text += "/" + new_item_text;
            }
        }

        event.Veto();   // Cancels further gui actions. reset_tree is going to do the job.
                        // If we don't veto, strange behavior may happen.

        fix_all();

        reset_tree(current_selection_text);
    }
}


void CTAFrame::on_new_var(wxCommandEvent &event)
{
    NewVarDlg dlg(this, wxID_ANY, "New variable");
    dlg.set_default_button_ok();
    int rc = dlg.ShowModal();

    if (rc == wxID_OK)
    {
        std::wstring variable_text = dlg.get_new_env_var_id().ToStdWstring();

        if (std::find(active_env_vars_->begin(),
                        active_env_vars_->end(),
                        variable_text) == active_env_vars_->end())
        {
            std::wstring new_value = dlg.get_new_value().ToStdWstring();

            // Create new EnvVar and push it into active_env_vars_
            EnvVar new_var(variable_text, new_value);
            active_env_vars_->push_back(new_var);

            // Prepare to select it after reset
            if (new_value.size() != 0)
            {
                variable_text += L"/" + new_value;
            }
            reset_tree(variable_text);
        }
        else
        {
            wxMessageBox(
                variable_text + " already exists.",
                "New variable",
                wxOK | wxICON_WARNING);
        }
    }

    fix_all();
}


void CTAFrame::on_new_value(wxCommandEvent &event)
{
    wxTreeItemId selected_item = active_tree_->GetSelection();

    if (!selected_item.IsOk())
    {
        wxMessageBox(
            "No variable selected to add value to.",
            "New value",
            wxOK | wxICON_WARNING);
        return;
    }

    // Variable or value ? (variable by default).
    if (active_tree_->GetItemParent(selected_item) != active_tree_->GetRootItem())
    {
        selected_item = active_tree_->GetItemParent(selected_item); // selection is a value (not a variable)
    }

    std::wstring variable_text = active_tree_->GetItemText(selected_item).ToStdWstring();

    NewVarDlg dlg(this, wxID_ANY, "New value");
    // Assign parameters to dialog.
    dlg.set_new_env_var_id(variable_text.c_str());
    dlg.disable_new_env_var_id();
    dlg.set_default_button_ok();
    // Show dialog.
    int rc = dlg.ShowModal();
    // Get value from dialog.
    std::wstring value = dlg.get_new_value().ToStdWstring();
    dlg.Destroy();

    if (rc == wxID_OK)
    {
        std::wstring prec;
        active_env_vars_->get_value(variable_text, prec);

        // Update value.
        if (prec.length() != 0)
        {
            active_env_vars_->set_value(variable_text, prec + L";" + value);
        }
        else
        {
            active_env_vars_->set_value(variable_text, value);
        }

        fix_all();

        reset_tree(variable_text + L"/" + value);
    }
}


void CTAFrame::on_delete(wxCommandEvent &event)
{
    wxTreeItemId selected_item = active_tree_->GetSelection();

    if (!selected_item.IsOk())
    {
        wxMessageBox(
            "Nothing selected.",
            "Deleting",
            wxOK | wxICON_WARNING);
        return;
    }

    // Get the item to delete (the selected one)
    std::wstring selected_item_text = active_tree_->GetItemText(selected_item).ToStdWstring();

    int rc = wxMessageBox(
                    "Really delete " + selected_item_text + " ? ",
                    "Deleting",
                    wxYES_NO | wxICON_QUESTION);

    if (rc == wxYES)
    {
        // Get the item text to select after deletion
        std::wstring target_after_del_text;
        get_item_text_to_select_after_deletion(selected_item, target_after_del_text);

        wxTreeItemId root = active_tree_->GetRootItem();

        wxTreeItemId parent = active_tree_->GetItemParent(selected_item);
        std::wstring parent_text;

        if (parent == root) // variable
        {
            EnvVarVect::iterator it = std::find(active_env_vars_->begin(),
                                                active_env_vars_->end(),
                                                selected_item_text);
            if (it != active_env_vars_->end())
            {
                active_env_vars_->erase(it);
            }
        }
        else // value
        {
            parent_text = active_tree_->GetItemText(parent).ToStdWstring();
            std::wstring variable_text = active_tree_->GetItemText(parent).ToStdWstring();

            std::wstring all_values;
            active_env_vars_->get_value(variable_text, all_values);

            // Parse values to work on each value entity.
            std::vector<std::wstring> tokens = parse(all_values, DELIM);

            std::vector<std::wstring> keep;

            std::vector<std::wstring>::iterator tok;
            for (tok = tokens.begin(); tok != tokens.end(); tok++)
            {
                // Keep only the ones not selected.
                if (*tok != selected_item_text)
                {
                    keep.push_back(*tok);
                }
            }

            // Rebuild the string
            std::wstring new_values = L"";
            for (tok = keep.begin(); tok != keep.end(); tok++)
            {
                if (new_values.length() != 0)
                {
                    new_values += L";";
                }

                new_values += *tok;
            }

            // Update values without the selected one.
            active_env_vars_->set_value(variable_text, new_values);
        }

        // Don't fix. We want to know what is the error if there is.

        reset_tree(target_after_del_text);

        if (parent != root)
        {
            // Expand

            wxTreeItemIdValue cookie;
            wxTreeItemId child = active_tree_->GetFirstChild(root, cookie);
            while (child.IsOk())
            {
                std::wstring child_text = active_tree_->GetItemText(child).ToStdWstring();

                if (child_text == parent_text)
                {
                    active_tree_->Expand(child);
                }

                child = active_tree_->GetNextChild(root, cookie);
            }
        }
    }
}


void CTAFrame::on_begin_edit(wxTreeEvent &event)
{
    if (!is_admin())
    {
        event.Veto();
    }
}


void CTAFrame::on_page_change(wxNotebookEvent &event)
{
    // When user changes page in notebook, assign active
    // EnvVarVect and tree (user or system).

    wxBusyCursor wait;

    if (notebook_1_->GetCurrentPage() == notebook_1_pane_user_)
    {
        active_env_vars_ = &env_vars_user_;
        active_tree_ = tree_ctrl_user_;
        checkbox_sorted_->Enable(1);
        button_fix_->Enable(1);
    }
    else
    {
        active_env_vars_ = &env_vars_system_;
        active_tree_ = tree_ctrl_system_;

        if (!is_admin())
        {
            bitmap_admin->Show(true);

            button_system_new_->Enable(0);
            button_system_new_value_->Enable(0);
            button_system_delete_->Enable(0);
            checkbox_sorted_->Enable(0);
            button_fix_->Enable(0);
        }
        else
        {
            bitmap_admin->Show(false);
        }
    }

    reset_tree();

    return;
}


void CTAFrame::on_button_about(wxCommandEvent &event)
{
    // Show information on CTA.

    InfoDlg dlg(this, -1, "What is CTA");
    dlg.ShowModal();

    std::wstring current_selection_text;
    get_current_selection_text(current_selection_text);
    give_focus_to(current_selection_text);
}


void CTAFrame::on_sort(wxCommandEvent &event)
{
    reset_according_to_sort_status();
}


void CTAFrame::on_button_up(wxCommandEvent &event)
{
    move(UP);
}


void CTAFrame::on_button_down(wxCommandEvent &event)
{
    move(DOWN);
}


void CTAFrame::on_button_fix(wxCommandEvent &event)
{
    fix_all();
}


void CTAFrame::on_button_reload(wxCommandEvent &event)
{
    bool bDirtyUser = false;
    bool bDirtySystem = false;
    dirty(bDirtyUser, bDirtySystem);

    bool reload_canceled(false);
    bool wanted_to_reload(false);
    bool reloaded(false);

    if (bDirtyUser || bDirtySystem)
    {
        wxString msg;
        msg.Printf("There are changes.\n\n"
                    "If you reload now, they will be lost.\n\n"
                    "Do you want to reload now?");
        int rc = wxMessageBox(msg,
                        "CTA",
                        wxYES_NO | wxICON_QUESTION);
        if (rc == wxYES)
        {
            wanted_to_reload = true;
            if (reload_env_vars())
            {
                reloaded = true;
            }
        }
        else
        {
            reload_canceled = true;
        }
    }

    if (setting_changed_from_outside_ && !reloaded && !reload_canceled)
    {
        wxString msg;
        msg.Printf("There are changes from outside.\n\n"
                    "If you reload now, you will overwrite current environment variables.\n\n"
                    "Do you want to reload now?");
        int rc = wxMessageBox(msg,
                        "CTA",
                        wxYES_NO | wxICON_QUESTION);
        if (rc == wxYES)
        {
            wanted_to_reload = true;
            if (reload_env_vars())
            {
                reloaded = true;
                setting_changed_from_outside_ = false;
            }
        }
        else
        {
            reload_canceled = true;
        }
    }

    if (wanted_to_reload)
    {
        if (reloaded)
        {
            wxMessageBox("Reload done.",
                            "CTA",
                            wxOK);
        }
        else
        {
            wxMessageBox("Failed to reload.",
                            "CTA",
                            wxOK);
        }
    }
    else
    {
        if (reload_canceled)
        {
            wxMessageBox("Reload canceled.",
                            "CTA",
                            wxOK);
        }
        else
        {
            wxMessageBox("No need to reload.",
                            "CTA",
                            wxOK);
        }
    }
}


void CTAFrame::on_button_export(wxCommandEvent &event)
{
    wxString file;
    if (export_env_vars(file))
    {
        wxString msg;
        msg.Printf("Exported to %s.", file.c_str());
        wxMessageBox(msg,
                    "Exporting environment variables",
                    wxOK | wxICON_INFORMATION);
    }
    else
    {
        wxString msg;
        msg.Printf("Failed to export to %s.", file.c_str());
        wxMessageBox(msg,
                    "Exporting environment variables",
                    wxOK | wxICON_ERROR);
    }
}


void CTAFrame::on_button_import(wxCommandEvent &event)
{
    import_env_vars();
}


void CTAFrame::on_button_save(wxCommandEvent &event)
{
    wxBusyCursor wait;

    bool bDirtyUser = false;
    bool bDirtySystem = false;
    dirty(bDirtyUser, bDirtySystem);

    if (bDirtyUser || bDirtySystem)
    {
        std::wstring msg;
        if (!save(bDirtyUser, bDirtySystem, msg))
        {
            wxMessageBox(
                msg.c_str(),
                "CTA",
                wxOK | wxICON_ERROR);
            reset_tree();
        }
    }
}


void CTAFrame::on_quit(wxCommandEvent &event)
{
    if (quit())
    {
        this->Destroy();
    }
}


// wxGlade: add CTAFrame event handlers


void CTAFrame::on_item_right_click(wxTreeEvent &event)
{
    // Popup two possible actions to do with the selected item.

    if (!is_admin() && active_tree_ == tree_ctrl_system_)
    {
        return;
    }

    wxTreeItemId item = event.GetItem();

    active_tree_->SelectItem(item);

    std::wstring new_value_target;
    std::wstring delete_target;

    if (active_tree_->GetItemParent(item) == active_tree_->GetRootItem())
    {
        new_value_target = active_tree_->GetItemText(item).ToStdWstring();
        delete_target = new_value_target;
    }
    else
    {
        delete_target = active_tree_->GetItemText(item).ToStdWstring();
        item = active_tree_->GetItemParent(item); // selection is a value (not a variable)
        new_value_target = active_tree_->GetItemText(item).ToStdWstring();
    }

    wxMenu menu;
    menu.Append(POPUP_NEW_VALUE, "New value for " + new_value_target);
    menu.Append(POPUP_DELETE, "Delete " + delete_target);

    wxPoint point = event.GetPoint();
    PopupMenu(&menu, point);
}


void CTAFrame::on_close(wxCloseEvent& event)
{
    if (quit())
    {
        this->Destroy();
    }
}

void CTAFrame::manual_mode()
{
    static bool toggle(true);

    if (toggle)
    {
        checkbox_sorted_->SetValue(false);
        checkbox_sorted_->Show();
        button_up_->Show();
        button_down_->Show();
        reset_according_to_sort_status();
    }
    else
    {
        checkbox_sorted_->SetValue(true);
        checkbox_sorted_->Hide();
        button_up_->Hide();
        button_down_->Hide();
        reset_according_to_sort_status();
    }

    toggle = !toggle;

    Layout();
}


void CTAFrame::set_properties()
{
    // begin wxGlade: CTAFrame::set_properties
    SetTitle(wxT("CTA"));
    tree_ctrl_system_->SetBackgroundColour(wxColour(249, 255, 185));
    bitmap_admin->SetToolTip(wxT("To update system environment variables, you must start CTA as administrator."));
    notebook_1_->SetMinSize(wxSize(600, 376));
    // end wxGlade
}


void CTAFrame::do_layout()
{
    // begin wxGlade: CTAFrame::do_layout
    wxBoxSizer* sizer_2 = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* sizer_5 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_1 = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* sizer_15 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_18 = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* sizer_17 = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* sizer_6 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_3 = new wxBoxSizer(wxVERTICAL);
    wxStaticBoxSizer* sizer_8 = new wxStaticBoxSizer(sizer_8_staticbox, wxVERTICAL);
    wxBoxSizer* sizer_4 = new wxBoxSizer(wxHORIZONTAL);
    wxStaticBoxSizer* sizer_7 = new wxStaticBoxSizer(sizer_7_staticbox, wxVERTICAL);
    wxBoxSizer* sizer_9 = new wxBoxSizer(wxHORIZONTAL);
    sizer_7->Add(tree_ctrl_user_, 1, wxEXPAND, 0);
    sizer_9->Add(button_user_new_var_, 0, wxALL, 5);
    sizer_9->Add(button_user_new_value_, 0, wxALL, 5);
    sizer_9->Add(button_user_delete_, 0, wxALL, 5);
    sizer_7->Add(sizer_9, 0, wxALL|wxALIGN_BOTTOM|wxALIGN_CENTER_HORIZONTAL, 5);
    notebook_1_pane_user_->SetSizer(sizer_7);
    sizer_8->Add(tree_ctrl_system_, 1, wxEXPAND, 0);
    sizer_4->Add(button_system_new_, 0, wxALL, 5);
    sizer_4->Add(button_system_new_value_, 0, wxALL, 5);
    sizer_4->Add(button_system_delete_, 0, wxALL, 5);
    sizer_4->Add(bitmap_admin, 0, wxALL|wxFIXED_MINSIZE, 7);
    sizer_8->Add(sizer_4, 0, wxALL|wxALIGN_BOTTOM|wxALIGN_CENTER_HORIZONTAL, 5);
    notebook_1_pane_system_->SetSizer(sizer_8);
    notebook_1_->AddPage(notebook_1_pane_user_, wxT("User environment variables"));
    notebook_1_->AddPage(notebook_1_pane_system_, wxT("System environment variables"));
    sizer_3->Add(notebook_1_, 3, wxEXPAND, 0);
    sizer_3->Add(list_box_msg, 1, wxEXPAND, 0);
    sizer_2->Add(sizer_3, 1, wxALL|wxEXPAND, 5);
    sizer_5->Add(bitmap_gpl, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 10);
    sizer_6->Add(button_about_, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 10);
    wxStaticText* label_info_ = new wxStaticText(this, wxID_ANY, wxT("After some actions, it may be necessary to click on 'Fix' button to solve problems."), wxDefaultPosition, wxDefaultSize, wxST_NO_AUTORESIZE);
    label_info_->SetMinSize(wxSize(200, 60));
    sizer_6->Add(label_info_, 0, wxTOP|wxBOTTOM|wxEXPAND|wxALIGN_CENTER_HORIZONTAL, 20);
    sizer_6->Add(checkbox_sorted_, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 5);
    sizer_6->Add(button_up_, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 5);
    sizer_6->Add(button_down_, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 5);
    sizer_6->Add(button_fix_, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 5);
    sizer_5->Add(sizer_6, 0, wxTOP|wxALIGN_CENTER_HORIZONTAL, 10);
    sizer_15->Add(button_reload_, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 5);
    sizer_17->Add(button_export_, 0, wxALL, 5);
    sizer_17->Add(button_import_, 0, wxALL, 5);
    sizer_15->Add(sizer_17, 1, wxALIGN_CENTER_HORIZONTAL, 0);
    sizer_18->Add(button_save_, 0, wxALL|wxALIGN_BOTTOM, 5);
    sizer_18->Add(button_quit_, 0, wxALL|wxALIGN_BOTTOM, 5);
    sizer_15->Add(sizer_18, 1, wxALIGN_CENTER_HORIZONTAL, 0);
    sizer_1->Add(sizer_15, 1, wxALIGN_BOTTOM, 0);
    sizer_5->Add(sizer_1, 1, wxALL|wxEXPAND|wxALIGN_BOTTOM|wxALIGN_CENTER_HORIZONTAL, 10);
    sizer_2->Add(sizer_5, 0, wxEXPAND, 0);
    SetSizer(sizer_2);
    sizer_2->Fit(this);
    sizer_2->SetSizeHints(this);
    Layout();
    // end wxGlade
}


void CTAFrame::load_env_vars()
{
    // User env. vars.
    std::wstring err_msg;
    if (!env_vars_user_.load(err_msg))
    {
        wxMessageBox(err_msg.c_str());
    }

    // System env. vars.
    if (!env_vars_system_.load(err_msg))
    {
        wxMessageBox(err_msg.c_str());
    }
}


void CTAFrame::reset_tree(const std::wstring & selection_text)
{
    // Resfresh content of active tree (the one shown by notebook).

    wxBusyCursor wait;

    // Reset messages
    details_.clear();

    // get a copy of active env. vars. to sort it eventually.
    EnvVarVect env_vars = *active_env_vars_;

    if (checkbox_sorted_->GetValue())
    {
        // Sort
        std::sort(env_vars.begin(), env_vars.end());
    }

    // Controls hidden to speed up insertion
    active_tree_->Show(0);

    // Delete all items.
    active_tree_->DeleteAllItems();

    wxTreeItemId root = active_tree_->AddRoot("EnvVars");

    bool bDirtyUser = false;
    bool bDirtySystem = false;
    dirty(bDirtyUser, bDirtySystem);

    EnvVarVect::iterator it;
    for (it = env_vars.begin(); it != env_vars.end(); it++)
    {
        std::wstring key = it->key_;
        std::wstring value = it->value_;

        // Child is a variable. Append variable.
        wxTreeItemId child = active_tree_->AppendItem(root, key.c_str());

        if (value.length() > 0)
        {
            // Check for bad path in each value (value <==> token)

            std::vector<std::wstring> tokens = parse(value, DELIM);

            std::vector<std::wstring>::iterator it_value;
            for (it_value = tokens.begin(); it_value != tokens.end(); it_value++)
            {
                // Append value item to variable item.
                active_tree_->AppendItem(child, it_value->c_str());
            }
        }
    }

    // error serves to unselect items when error occurs.
    // This allows to see where errors are.
    bool error = check_cyclic_reference();

    if (!error)
    {
        // It is better to fix cyclic references before
        // doing other tests...

        // check_paths() try to resolve references. To avoid
        // inifite loop, we must call check_paths() when
        // there is no cyclic references only.
        check_paths();

        check_order();
    }

    give_focus_to(selection_text);

    // Cancel the previous Show(0) command to allow actual display.
    active_tree_->Show(1);

    reset_msg();
}


void CTAFrame::reset_msg()
{
    list_box_msg->Clear();
    int i(0);
    std::vector<std::wstring>::iterator it;
    for (it = details_.begin(); it != details_.end(); it++)
    {
        wxString strDetail(*it);
        list_box_msg->InsertItems(1, &strDetail, i);

        ++i;
    }
}


void CTAFrame::set_font_bad(wxTreeItemId & item)
{
    wxFont font = active_tree_->GetItemFont(item);
    font.SetUnderlined(true);

    // small font is needed here because underline state
    // grows the font (?)
    font.SetSymbolicSize(wxFONTSIZE_SMALL);

    active_tree_->SetItemFont(item, font);
}


bool CTAFrame::check_paths()
{
    bool error(false);

    // We suppose we are working on system env. vars.
    EnvVarVect * env_vars = &env_vars_system_;
    bool user  = (notebook_1_->GetCurrentPage() == notebook_1_pane_user_);
    if (user)
    {
        // Oups, finally, we are working on user env. vars.
        env_vars = &env_vars_user_;
    }

    std::vector<EnvVar> bad_paths;
    EnvVarVect::iterator it;
    for (it = env_vars->begin(); it != env_vars->end(); it++)
    {
        std::vector<std::wstring> paths;
        if (value_has_bad_path(it->value_, paths))
        {
            std::vector<std::wstring>::iterator it_paths;
            for (it_paths = paths.begin(); it_paths != paths.end(); it_paths++)
            {
                EnvVar env_var(it->key_, *it_paths);
                bad_paths.push_back(env_var);
            }
        }
    }

    if (bad_paths.size() != 0)
    {
        std::vector<EnvVar>::iterator it_bad_paths;
        for (it_bad_paths = bad_paths.begin(); it_bad_paths != bad_paths.end(); it_bad_paths++)
        {
            std::wstring key = it_bad_paths->key_;
            std::wstring bad_path = it_bad_paths->value_;

            // Set the color.
            wxTreeItemId root = active_tree_->GetRootItem();
            wxTreeItemIdValue cookie;
            wxTreeItemId child = active_tree_->GetFirstChild(root, cookie);
            while (child.IsOk())
            {
                std::wstring variable_text = active_tree_->GetItemText(child).ToStdWstring();

                if (key == variable_text)
                {
                    error = true;

                    // Set colors for the variable.
                    active_tree_->SetItemBackgroundColour(child, bad_path_background);
                    active_tree_->SetItemTextColour(child, bad_path_foreground);
                    set_font_bad(child);

                    // Get values
                    wxTreeItemIdValue cookie_item;
                    wxTreeItemId value_item = active_tree_->GetFirstChild(child, cookie_item);
                    while (value_item.IsOk())
                    {
                        std::wstring value_text = active_tree_->GetItemText(value_item).ToStdWstring();

                        if (value_text == bad_path)
                        {
                            // Set colors for the value.
                            active_tree_->SetItemBackgroundColour(value_item, bad_path_background);
                            active_tree_->SetItemTextColour(value_item, bad_path_foreground);
                            set_font_bad(value_item);
                        }

                        value_item = active_tree_->GetNextChild(child, cookie_item);
                    }

                    // Messages...
                    std::wstring detail;
                    detail += L"'" + bad_path + "' is not a valid path or file.";
                    details_.push_back(detail);
                }

                child = active_tree_->GetNextChild(root, cookie);
            }
        }
    }

    return error;
}


bool CTAFrame::value_has_bad_path(const std::wstring & value, std::vector<std::wstring> & paths)
{
    std::vector<std::wstring> tokens = parse(value, DELIM);
    std::vector<std::wstring>::iterator it_tok;
    for (it_tok = tokens.begin(); it_tok != tokens.end(); it_tok++)
    {
        std::string token = narrow(*it_tok);

        // Remove trailing backslashes
        while(pcrecpp::RE("(.*)\\\\$", pcrecpp::UTF8()).FullMatch(token, &token));

        // Expand environment variables
        pcrecpp::StringPiece input(token);

        // pcrepcpp::RE is a pcre (Perl Compatible Regular Expression)
        // Find and replace each env. var. (%ENV_VAR% format) with its value.
        std::string id;
        while (pcrecpp::RE("%(.*?)%", pcrecpp::UTF8()).FindAndConsume(&input, &id))
        {
            std::string strValue;

            std::wstring wstrValue;
            if (active_env_vars_->get_value(widen(id), wstrValue))
            {
                strValue = narrow(wstrValue); // convert to std::string
            }
            else
            {
                // Maybe the variable is a special one (see EnvVarVectSpecial ctr).
                if (env_vars_special_.get_value(widen(id), wstrValue))
                {
                    strValue = narrow(wstrValue); // convert to std::string
                }
            }

            // Doubles backslashes (one backslash worth 4 in re: 2 for perl and 2 for C++)
            pcrecpp::RE("(\\\\)", pcrecpp::UTF8()).GlobalReplace("\\\\\\\\", &strValue);

            // Replace the value of token by the new one from env. var.
            if (!pcrecpp::RE("%(.*?)%", pcrecpp::UTF8()).Replace(strValue, &token))
                ;//break;  // TO_DO (assert ?)

            input = token;
        }

        // Replace slashes by backslashes
        pcrecpp::RE("/", pcrecpp::UTF8()).GlobalReplace("\\\\", &token);

        // Check if file or directory exists
        if (pcrecpp::RE("^([a-zA-Z]\\:|\\\\\\\\[^\\/\\\\:*?\"<>|]+\\\\[^\\/\\\\:*?\"<>|]+)(\\\\[^\\/\\\\:*?\"<>|]+)*$", pcrecpp::UTF8()).FullMatch(token))
        {
            // Does file or path exist?
            if (GetFileAttributesA(token.c_str()) == INVALID_FILE_ATTRIBUTES)
            {
                paths.push_back(*it_tok);
            }
        }
    }

    return (paths.size() != 0);
}


bool CTAFrame::check_cyclic_reference()
{
    // We suppose we are working on system env. vars.
    EnvVarVect * env_vars = &env_vars_system_;
    bool user  = (notebook_1_->GetCurrentPage() == notebook_1_pane_user_);
    if (user)
    {
        // Oups, finally, we are working on user env. vars.
        env_vars = &env_vars_user_;
    }

    // Find cyclic references.
    std::vector<EnvVar> cyclic_refs;
    EnvVarVect::iterator it;
    for (it = env_vars->begin(); it != env_vars->end(); it++)
    {
        std::wstring key = it->key_;
        std::wstring value = it->value_;

        std::wstring referenced_key;
        if (value_has_reference_on_key(value, key, referenced_key))
        {
            EnvVar couple(key, referenced_key);
            cyclic_refs.push_back(couple);
        }
    }

    // Set the color for variables that are part of cyclic reference.
    if (cyclic_refs.size() != 0)
    {
        std::vector<EnvVar>::iterator it_cyclic_refs;
        for (it_cyclic_refs = cyclic_refs.begin(); it_cyclic_refs != cyclic_refs.end(); it_cyclic_refs++)
        {
            std::wstring key = it_cyclic_refs->key_;

            // Set the color.
            wxTreeItemId root = active_tree_->GetRootItem();
            wxTreeItemIdValue cookie;
            wxTreeItemId child = active_tree_->GetFirstChild(root, cookie);
            while (child.IsOk())
            {
                std::wstring child_text = active_tree_->GetItemText(child).ToStdWstring();

                if (key == child_text)
                {
                    active_tree_->SetItemBackgroundColour(child, bad_order_background);
                    active_tree_->SetItemTextColour(child, bad_order_foreground);
                    set_font_bad(child);


                    std::wstring detail;
                    detail += L"Cyclic reference between " + key + " and " + it_cyclic_refs->value_ + L".";
                    details_.push_back(detail);
                }

                child = active_tree_->GetNextChild(root, cookie);
            }
        }

        return true;
    }

    return false;
}


bool CTAFrame::value_has_reference_on_key(const std::wstring & value, std::wstring & key, std::wstring & referenced_key)
{
    std::vector<std::wstring> tokens = parse(value, DELIM);
    std::vector<std::wstring>::iterator it_tok;
    for (it_tok = tokens.begin(); it_tok != tokens.end(); it_tok++)
    {
        std::string token = narrow(*it_tok);

        pcrecpp::StringPiece input(token);

        std::string id;
        while (pcrecpp::RE("%(.*?)%", pcrecpp::UTF8()).FindAndConsume(&input, &id))
        {
            std::wstring token_value;
            active_env_vars_->get_value(widen(id), token_value);

            std::wstring key_with_perc = std::wstring(L"%") + key + L"%";
            if (token_value.find(key_with_perc) != std::wstring::npos)
            {
                referenced_key = widen(id);
                return true;
            }
        }
    }

    return false;
}


bool CTAFrame::check_order()
{
    // When variables are in bad order, we show to user
    // which variables are in bad order.

    bool error(false);

    // We suppose we are working on system env. vars.
    EnvVarVect * env_vars = &env_vars_system_;

    bool user  = (notebook_1_->GetCurrentPage() == notebook_1_pane_user_);

    if (user)
    {
        // Oups, finally, we are working on user env. vars.
        env_vars = &env_vars_user_;
    }

    std::map<std::wstring, std::vector<std::wstring> > to_fix;
    get_env_vars_to_fix(env_vars, to_fix);

    // Set messages according to bad ordered env. vars.
    std::map<std::wstring, std::vector<std::wstring> >::iterator it_to_fix;
    for (it_to_fix = to_fix.begin(); it_to_fix != to_fix.end(); it_to_fix++)
    {
        std::wstring dependy = it_to_fix->first;
        std::vector<std::wstring> dependencies = it_to_fix->second;

        std::wstring detail = dependy + L": dependency issue with ";
        std::vector<std::wstring>::iterator it_dependencies;
        for (it_dependencies = dependencies.begin(); it_dependencies != dependencies.end(); it_dependencies++)
        {
            std::wstring sep(L"");
            if (it_dependencies == dependencies.begin())
            {
                sep = L"";
            }
            else
            {
                sep = L", ";
            }

            std::wstring dependency_id = *it_dependencies;

            detail += sep + dependency_id;
        }
        detail += L"  (if 'Fix' button doesn't work, check if depedencies exist).";
        details_.push_back(detail);
    }

    // Set the color for bad ordered variables.
    wxTreeItemId root = active_tree_->GetRootItem();
    wxTreeItemIdValue cookie;
    wxTreeItemId child = active_tree_->GetFirstChild(root, cookie);
    while (child.IsOk())
    {
        std::wstring child_text = active_tree_->GetItemText(child).ToStdWstring();

        std::map<std::wstring, std::vector<std::wstring> >::iterator it_to_fix;
        for (it_to_fix = to_fix.begin(); it_to_fix != to_fix.end(); it_to_fix++)
        {
            if (it_to_fix->first == child_text)
            {
                active_tree_->SetItemBackgroundColour(child, bad_order_background);
                active_tree_->SetItemTextColour(child, bad_order_foreground);

                set_font_bad(child);

                error = true;
            }
        }

        child = active_tree_->GetNextChild(root, cookie);
    }

    return error;
}


void CTAFrame::give_focus_to(const std::wstring & selection_text, wxTreeItemId * parent)
{
    // Give the focus back to the selected variable/value before the tree refresh.

    if (selection_text.empty())
    {
        return;
    }

    wxTreeItemId root = active_tree_->GetRootItem();

    if (!parent)
    {
        parent = &root;
    }

    wxTreeItemIdValue cookie;
    wxTreeItemId child = active_tree_->GetFirstChild(*parent, cookie);

    while (child.IsOk())
    {
        std::wstring child_text = active_tree_->GetItemText(child).ToStdWstring();

        std::wstring selected_parent_text;
        std::wstring selected_item_text;
        if (parent == &root) // variable
        {
            if (child_text == selection_text)
            {
                active_tree_->SelectItem(child);
                active_tree_->EnsureVisible(child);
            }
        }
        else // value
        {
            std::wstring parent_text = active_tree_->GetItemText(*parent).ToStdWstring();

            std::string sel_text(narrow(selection_text));
            std::string sel_parent_text(narrow(selected_parent_text));
            std::string sel_item_text(narrow(selected_item_text));
            pcrecpp::RE("(.*?)/(.*?)", pcrecpp::UTF8()).FullMatch(sel_text, &sel_parent_text, &sel_item_text);
            selected_parent_text = widen(sel_parent_text);
            selected_item_text = widen(sel_item_text);

            if (child_text == selected_item_text
                && parent_text == selected_parent_text.c_str())
            {
                active_tree_->SelectItem(child);
                active_tree_->EnsureVisible(child);
            }
        }

        give_focus_to(selection_text, &child);

        child = active_tree_->GetNextChild(*parent, cookie);
    }

    active_tree_->SetFocus();
}


void CTAFrame::get_current_selection_text(std::wstring & selection_text)
{
    // Before refreshing the tree, we get the currently selected variable/value.

    selection_text = L"";

    wxTreeItemId sel = active_tree_->GetSelection();

    if (sel.IsOk())
    {
        wxTreeItemId parent = active_tree_->GetItemParent(sel);
        if (parent != active_tree_->GetRootItem())
        {
            selection_text += active_tree_->GetItemText(parent) + "/";
        }

        selection_text += active_tree_->GetItemText(sel);
    }
}


void CTAFrame::get_item_text_to_select_after_deletion(wxTreeItemId & item_to_del, std::wstring & selection_text)
{
    selection_text = L"";

    std::wstring parent_item_text;

    bool is_value(false);
    wxTreeItemId parent = active_tree_->GetItemParent(item_to_del);
    if (parent != active_tree_->GetRootItem())
    {
        // Value
        is_value = true;
        parent_item_text = active_tree_->GetItemText(parent);
    }
    else
    {
        // Variable
    }

    // Here is the trick
    std::wstring target_item_text;
    wxTreeItemId target_after_del_child = active_tree_->GetNextSibling(item_to_del);
    if (!target_after_del_child.IsOk())
    {
        target_after_del_child = active_tree_->GetPrevSibling(item_to_del);
        if (target_after_del_child.IsOk())
        {
            target_item_text = active_tree_->GetItemText(target_after_del_child).ToStdWstring();
        }
    }
    else
    {
        target_item_text = active_tree_->GetItemText(target_after_del_child).ToStdWstring();
    }

    // If there is no more values, we select the parent (no need of /)
    std::wstring sep;
    if (is_value && !target_item_text.empty())
    {
        sep = L"/";
    }

    selection_text = parent_item_text + sep + target_item_text;
}


void CTAFrame::move(enum_direction direction)
{
    wxTreeItemId selected_item = active_tree_->GetSelection();

    if (!selected_item.IsOk())
    {
        return;
    }

    std::wstring current_selection_text;
    get_current_selection_text(current_selection_text);

    wxTreeItemId root = active_tree_->GetRootItem();
    wxTreeItemId parent = active_tree_->GetItemParent(selected_item);

    // Fills "elements" with the items in the current order in the tree.
    std::vector<std::wstring> elements;
    wxTreeItemIdValue cookie;
    wxTreeItemId child = active_tree_->GetFirstChild(parent, cookie);
    while(child.IsOk())
    {
        elements.push_back(active_tree_->GetItemText(child).ToStdWstring());

        child = active_tree_->GetNextChild(parent, cookie);
    }

    // Create raw hash according to order in tree.
    std::vector<std::wstring> hash_raw(elements);


    // Find index of the selected item.

    std::wstring selected_item_text = active_tree_->GetItemText(selected_item).ToStdWstring();

    size_t idx = 0;

    std::vector<std::wstring>::iterator it_elem;
    for (it_elem = elements.begin(); it_elem != elements.end(); it_elem++)
    {
        if (selected_item_text == *it_elem)
        {
            if (direction == UP)
            {
                if (idx == 0)
                {
                    // Top reached.
                    reset_tree(current_selection_text);
                    return;
                }
            }
            else
            {
                if (idx == elements.size() - 1)
                {
                    // Bottom reached.
                    reset_tree(current_selection_text);
                    return;
                }
            }

            break;
        }

        ++idx;
    }

    // Make move.

    long inc = (direction == UP) ? -1 : 1;

    // Swap values
    std::wstring tmp = hash_raw[idx + inc];
    hash_raw[idx + inc] = selected_item_text;
    hash_raw[idx] = tmp;

    if (parent == root) // variable
    {
        // Create new hash with items in the right order.
        std::vector<EnvVar> hash_new;

        long i(0);
        for (it_elem = hash_raw.begin(); it_elem != hash_raw.end(); it_elem++)
        {
            // Get value from active env. vars.
            std::wstring value;
            active_env_vars_->get_value(hash_raw[i], value);

            EnvVar var(hash_raw[i], value);
            hash_new.push_back(var);
            ++i;
        }

        // Replace active env_vars with newly ordered hash.
        active_env_vars_->clear();
        *active_env_vars_ = hash_new;
    }
    else // value
    {
        // Rebuild value string.
        std::wstring values = L"";

        long i(0);
        for (it_elem = hash_raw.begin(); it_elem != hash_raw.end(); it_elem++)
        {
            if (values.length() != 0)
            {
                values += L";" + hash_raw[i];
            }
            else
            {
                values += hash_raw[i];
            }

            std::wstring parent_text = active_tree_->GetItemText(parent).ToStdWstring();

            // Update the value.
            active_env_vars_->set_value(parent_text, values);

            ++i;
        }
    }

    reset_tree(current_selection_text);
}


void CTAFrame::dirty(bool & bDirtyUser, bool & bDirtySystem)
{
    // Did change happen?
    is_dirty(initial_user_env_vars_, env_vars_user_, bDirtyUser);
    is_dirty(initial_system_env_vars_, env_vars_system_, bDirtySystem);
}


void CTAFrame::is_dirty(const EnvVarVect & initial_env_vars, const EnvVarVect & env_vars, bool & bDirty)
{
    // env. vars. deleted ?
    long i(0);
    EnvVarVect::const_iterator it;
    for (it = initial_env_vars.begin(); it != initial_env_vars.end(); it++)
    {
        if (std::find(env_vars.begin(),
                        env_vars.end(),
                        it->key_) == env_vars.end())
        {
            //~ wxLogDebug("deleted: %s", it->key_);
            bDirty = true;
            break;
        }
    }

    if (!bDirty) // We need to continue searching dirty values only when we did not find yet.
    {
        // new env. vars. ?
        i = 0;
        for (it = env_vars.begin(); it != env_vars.end(); it++)
        {
            if (std::find(initial_env_vars.begin(),
                            initial_env_vars.end(),
                            it->key_) == initial_env_vars.end())
            {
                //~ wxLogDebug("new: %s", it->key_);
                bDirty = true;
                break;
            }

            ++i;
        }

        if (!bDirty) // We need to continue searching dirty values only when we did not find yet.
        {
            long i(0);
            EnvVarVect::const_iterator it;
            for (it = initial_env_vars.begin(); it != initial_env_vars.end(); it++)
            {
                // good variables order ?
                if (it->key_ != env_vars.operator[](i).key_)
                {
                    //~ wxLogDebug("variable order: %s", it->key_);
                    bDirty = true;
                    break;
                }

                // good values order
                if (it->value_ !=  env_vars.operator[](i).value_)
                {
                    //~ wxLogDebug("value order: %s", it->key_);
                    bDirty = true;
                    break;
                }

                ++i;
            }
        }
    }
}


bool CTAFrame::save(bool bDirtyUser, bool bDirtySystem, std::wstring & msg)
{
    wxBusyCursor wait;

    wxString file;
    if (!export_env_vars(file))
    {
        reset_tree();
        return false;
    }

    bool err(false);

    if (bDirtyUser)
    {
        cta_is_changing_setting_ = true;
        std::wstring err_msg;
        if (!env_vars_user_.save(err_msg))
        {
            env_vars_user_ = initial_user_env_vars_;
            err = true;
            msg += err_msg + "\n\n";
        }
        else
        {
            cta_is_changing_setting_ = false;
            initial_user_env_vars_ = env_vars_user_;
            msg += L"\n\nUser environment variables saved.\n\n";
        }
    }

    if (bDirtySystem)
    {
        cta_is_changing_setting_ = true;
        std::wstring err_msg;
        if (!env_vars_system_.save(err_msg))
        {
            err = true;
            env_vars_system_ = initial_system_env_vars_;
            msg += err_msg + "\n\n";
        }
        else
        {
            cta_is_changing_setting_ = false;
            initial_system_env_vars_ = env_vars_system_;
        }
    }

    std::wstring current_selection_text;
    get_current_selection_text(current_selection_text);
    give_focus_to(current_selection_text);

    if (err)
    {
        return false;
    }

    button_reload_->SetBackgroundColour(default_background_button);

    return true;
}


void CTAFrame::get_admin_status()
{
    // Did we start CTA with Administrative priviledges ?
    // That is to say, from Explorer: "Run as administrator" or
    // with UAC turned off.

    BOOL b;
    SID_IDENTIFIER_AUTHORITY NtAuthority = {SECURITY_NT_AUTHORITY};
    PSID AdministratorsGroup;
    b = AllocateAndInitializeSid(
        &NtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &AdministratorsGroup);
    if(b)
    {
        if (!CheckTokenMembership( NULL, AdministratorsGroup, &b))
        {
             b = FALSE;
        }
        FreeSid(AdministratorsGroup);
    }

    admin_ = b;
}

void CTAFrame::get_env_vars_to_fix(EnvVarVect * env_vars, std::map<std::wstring, std::vector<std::wstring> > & to_fix)
{
    to_fix.clear();

    std::vector<std::wstring> known_vars;

    // Special env. vars. are known by system env. vars. and by user env. vars.
    std::vector<EnvVar>::iterator it_env_var;
    for (it_env_var = env_vars_special_.begin(); it_env_var != env_vars_special_.end(); it_env_var++)
    {
        std::wstring key(it_env_var->key_);
        known_vars.push_back(key);
    }

    if (env_vars == &env_vars_user_)
    {
        // When we work on user env. vars., they must rely on system env. vars.
        for (it_env_var = env_vars_system_.begin(); it_env_var != env_vars_system_.end(); it_env_var++)
        {
            std::wstring wstr_key(it_env_var->key_);
            std::transform(wstr_key.begin(), wstr_key.end(), wstr_key.begin(), ::toupper);

            // Push system env. vars. that are not special into known_vars.
            if (std::find(known_vars.begin(), known_vars.end(), wstr_key) == known_vars.end())
            {
                known_vars.push_back(wstr_key);
            }
        }
    }
    else
    {
        // System env. vars. rely on special ones only.
    }

    EnvVarVect::iterator it;
    for (it = env_vars->begin(); it != env_vars->end(); it++)
    {
        std::wstring key = it->key_;
        std::wstring value = it->value_;

        known_vars.push_back(key); // Now, this variable is known.

        std::vector<std::wstring> tokens = parse(value, DELIM);

        // For each value of the variable, resolve
        // env. var. (%XYZ% ==> XYZ) and check its existence in known
        // variables. If not, the key is a candidate to fix.
        std::vector<std::wstring>::iterator it_tok;
        for (it_tok = tokens.begin(); it_tok != tokens.end(); it_tok++)
        {
            std::string var_value = narrow(*it_tok);

            pcrecpp::StringPiece string_piece_var_value(var_value);

            // When %XYZ% is found in var_value, replace it %XYZ% by XYZ to let FindAndConsume find other %ABC%.
            std::string variable_name;
            while (pcrecpp::RE("%(.*?)%", pcrecpp::UTF8()).FindAndConsume(&string_piece_var_value, &variable_name))
            {
                if (std::find(known_vars.begin(), known_vars.end(), widen(variable_name)) == known_vars.end())
                {
                    to_fix[key].push_back(widen(variable_name));
                }

                // Replace every substring in var_value that corresponds to %XYZ% pattern by it's variable name (XYZ).
                // this lets FindAndConsume do the job with other string with the %blablabla% pattern
                if (!pcrecpp::RE("%(.*?)%", pcrecpp::UTF8()).Replace(variable_name, &var_value))
                    ;//break;  // TO_DO (assert ?)

                string_piece_var_value = var_value;
            }
        }
    }
}

void CTAFrame::fix(EnvVarVect & env_vars, std::map<std::wstring, std::vector<std::wstring> > & to_fix)
{
    std::vector<EnvVar> hash_new;

    EnvVarVect::iterator it;
    for (it = env_vars.begin(); it != env_vars.end(); it++)
    {
        std::wstring key = it->key_;
        std::wstring value = it->value_;

        // Put in hash_new env. vars. on which the current env. var. (iterator) depends on
        // before this current env. var.
        if (to_fix.find(key) != to_fix.end())
        {
            std::vector<std::wstring> dependencies = to_fix[key];
            std::vector<std::wstring>::iterator it_dependencies;
            for (it_dependencies = dependencies.begin(); it_dependencies != dependencies.end(); it_dependencies++)
            {
                std::wstring dependency_id = *it_dependencies;

                if (std::find(hash_new.begin(),
                                hash_new.end(),
                                dependency_id) == hash_new.end())
                {
                    // dependency_id is not in hash_new yet.

                    if (std::find(env_vars.begin(), env_vars.end(), dependency_id) != env_vars.end())
                    {
                        // Add dependency_id env. var. only if it exists in env_vars.
                        // If we would add dependency_id env. var. when it doesn't exist,
                        // it could induce unexpected env. var.
                        std::wstring wstrValue;
                        env_vars.get_value(dependency_id, wstrValue);

                        EnvVar env_var(dependency_id, wstrValue);
                        hash_new.push_back(env_var);
                    }
                }
            }
        }

        if (std::find(hash_new.begin(),
                        hash_new.end(),
                        key) == hash_new.end())
        {
            EnvVar env_var(key, value);
            hash_new.push_back(env_var);
        }
    }

    env_vars.clear();
    env_vars = hash_new;
}

void CTAFrame::fix_all()
{
    // To fix all problems at once, we loop as long as problems can
    // be fixed automatically. Problems that can be fixed automatically
    // disappear one by one while problems that can't be fixed automatically
    // remain. When this happens, the size of 'previous' and
    // 'to_fix_user' or 'to_fix_system' vectors are the same.

    std::map<std::wstring, std::vector<std::wstring> > previous;

    std::map<std::wstring, std::vector<std::wstring> > to_fix_user;
    get_env_vars_to_fix(&env_vars_user_, to_fix_user);

    while (previous.size() != to_fix_user.size())
    {
        previous = to_fix_user;
        fix(env_vars_user_, to_fix_user);
        to_fix_user.clear();
        get_env_vars_to_fix(&env_vars_user_, to_fix_user);
    }

    previous.clear();

    std::map<std::wstring, std::vector<std::wstring> > to_fix_system;
    get_env_vars_to_fix(&env_vars_system_, to_fix_system);

    while (previous.size() != to_fix_system.size())
    {
        previous = to_fix_system;
        fix(env_vars_system_, to_fix_system);
        to_fix_system.clear();
        get_env_vars_to_fix(&env_vars_system_, to_fix_system);
    }

    reset_tree();
}

void CTAFrame::reset_according_to_sort_status()
{
    // According to sort option, sort the variables or not and refresh.

    if (checkbox_sorted_->GetValue())
    {
        button_up_->Enable(0);
        button_down_->Enable(0);
    }
    else
    {
        button_up_->Enable(1);
        button_down_->Enable(1);
    }

    std::wstring current_selection_text;
    get_current_selection_text(current_selection_text);

    reset_tree(current_selection_text);
}

bool CTAFrame::quit()
{
    wxBusyCursor wait;

    bool bDirtyUser = false;
    bool bDirtySystem = false;
    dirty(bDirtyUser, bDirtySystem);

    if (bDirtyUser || bDirtySystem)
    {
        int rc = wxMessageBox(
                    "Do you want to save changes ?",
                    "Exiting CTA?",
                    wxYES_NO | wxCANCEL | wxICON_QUESTION);

        if (rc == wxCANCEL)
        {
            return false;
        }

        if (rc == wxYES)
        {
            std::wstring msg;
            if (!save(bDirtyUser, bDirtySystem, msg))
            {
                wxMessageBox(
                    msg.c_str(),
                    "CTA",
                    wxOK | wxICON_ERROR);
                reset_tree();
                return false;
            }
        }
    }

    active_tree_->Show(0);

    return true;
}


bool CTAFrame::export_env_vars(wxString & target_file)
{
    std::string backup_dir = get_backup_dir();
    mkdir(backup_dir.c_str());

    // Create readme file.
    std::string readme = backup_dir + "\\readme";
    FILE * pf = fopen(readme.c_str(), "wt");
    fprintf(pf, "CTA is an environment variable editor for Windows.\n\n"
            "The files in this directory are generated each time CTA saves\n"
            "environment variables or when environment variables are exported.\n\n"
            "Each file contains environment variables before the save operation\n"
            "at the moment indicated by the file itself.\n");
    fclose(pf);

    // Target file name...
    SYSTEMTIME st;
    GetLocalTime(&st);

    target_file.Printf(wxT("%s\\env_vars-%04d-%02d-%02d_%02dh%02dm%02ds.cta"),
                        widen(backup_dir),
                        //~ widen(getenv("USERNAME")),
                        st.wYear,
                        st.wMonth,
                        st.wDay,
                        st.wHour,
                        st.wMinute,
                        st.wSecond);

    // Create the file and fill it.
    pf = fopen(target_file.c_str(), "wt");
    if (pf)
    {
        // User env. vars.
        std::vector<EnvVar> vect = env_vars_user_;
        std::sort(vect.begin(), vect.end());
        EnvVarVect::iterator it;
        for (it = vect.begin(); it != vect.end(); it++)
        {
            std::wstring key = it->key_;
            std::wstring value = it->value_;

            fwprintf(pf, L"user: %s = %s\n", key.c_str(), value.c_str());
        }

        // System env. vars.
        vect = env_vars_system_;
        std::sort(vect.begin(), vect.end());
        for (it = vect.begin(); it != vect.end(); it++)
        {
            std::wstring key = it->key_;
            std::wstring value = it->value_;

            fwprintf(pf, L"system: %s = %s\n", key.c_str(), value.c_str());
        }

        fclose(pf);
    }
    else
    {
        wxString msg;
        msg.Printf("Exporting environment variables failed.\n\nFailed to open %s.",
                    target_file.c_str());
        wxMessageBox(msg.c_str(),
                    "Exporting environment variables",
                    wxOK | wxICON_WARNING);
        return false;
    }

    cleanup_files(backup_dir);

    return true;
}

bool CTAFrame::import_env_vars()
{
    std::string backup_dir = get_backup_dir();

    std::vector<std::string> files;
    if (get_dir(backup_dir, files) == 0)
    {
        if (files.size() == 0)
        {
            wxMessageBox(
                "No backup file available.",
                "Importing environment variables",
                wxOK | wxICON_WARNING);
            return true;
        }

        std::vector<std::string> vect;
        std::vector<std::string>::iterator it;
        for (it = files.begin(); it != files.end(); it++)
        {
            size_t found1 = it->find("-");
            if (found1 != std::string::npos)
            {
                vect.push_back(*it);
            }
        }

        std::sort(vect.begin(), vect.end());

        ImportDlg dlg(&env_vars_user_, &env_vars_system_, this, -1, "Available import files");
        dlg.set_files(vect);
        dlg.ShowModal();
        fix_all();
        reset_tree();
    }
    else
    {
        wxMessageBox(
            "Can't get backup file list.",
            "Importing environment variables",
            wxOK | wxICON_ERROR);
    }

    // TO_DO
    return true;
}


bool CTAFrame::reload_env_vars()
{
    bool reloaded(true);

    EnvVarVect backup_user = env_vars_user_;
    EnvVarVect backup_system = env_vars_system_;

    // User env. vars.
    std::wstring err_msg;
    if (!env_vars_user_.reload(err_msg))
    {
        wxMessageBox(err_msg.c_str());
    }
    else
    {
        reloaded = true;
    }

    if (reloaded)
    {
        // OK, user env. vars. have been reloaded.
        // Now, reload system env. vars. too.

        // System env. vars.
        if (!env_vars_system_.reload(err_msg))
        {
            wxMessageBox(err_msg.c_str());
        }
        else
        {
            reloaded = true;
        }
    }

    if (reloaded)
    {
        // All have been reloaded.

        fix_all();

        //#define SAVE_WHEN_RELOAD
        #ifdef SAVE_WHEN_RELOAD
            bool bDirtyUser = false;
            bool bDirtySystem = false;
            dirty(bDirtyUser, bDirtySystem);

            if (bDirtyUser || bDirtySystem)
            {
                std::wstring msg;
                if (!save(bDirtyUser, bDirtySystem, msg))
                {
                    wxMessageBox(
                        msg.c_str(),
                        "CTA",
                        wxOK | wxICON_ERROR);
                    reset_tree();
                }
            }
            initial_user_env_vars_ = env_vars_user_;
            initial_system_env_vars_ = env_vars_system_;
        #endif

        button_reload_->SetBackgroundColour(default_background_button);

        return true;
    }
    else
    {
        // Rollback
        env_vars_user_ = backup_user;
        env_vars_system_ = backup_system;
    }

    return false;
}

bool CTAFrame::HandleSettingChange(WXWPARAM wParam, WXLPARAM lParam)
{
    if (!cta_is_changing_setting_)
    {
        std::wstring p((wchar_t *)lParam);
        std::wstring e(L"Environment");

        if (p == e)
        {
            setting_changed_from_outside_ = true;

            //~ wxMessageBox(
                //~ "Something else changed 'Environment'.",
                //~ "External event on 'Environment'.",
                //~ wxOK | wxICON_WARNING);

            std::wstring detail(L"Another application just changed the environment");
            details_.push_back(detail);

            reset_msg();

            button_reload_->SetBackgroundColour(yellow);
        }
    }

    return true;
}
